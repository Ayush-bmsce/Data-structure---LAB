1.Brute force
from collections import deque

# Goal state
goal = [[1,2,3],
        [4,5,6],
        [7,8,0]]   # 0 = blank

# Move directions
moves = [(1,0), (-1,0), (0,1), (0,-1)]  # Down, Up, Right, Left

def find_blank(state):
    for i in range(3):
        for j in range(3):
            if state[i][j] == 0:
                return i, j

def is_goal(state):
    return state == goal

def get_neighbors(state):
    x, y = find_blank(state)
    neighbors = []
    for dx, dy in moves:
        nx, ny = x + dx, y + dy
        if 0 <= nx < 3 and 0 <= ny < 3:
            new_state = [row[:] for row in state]
            new_state[x][y], new_state[nx][ny] = new_state[nx][ny], new_state[x][y]
            neighbors.append(new_state)
    return neighbors

def dfs(start, depth_limit=50):
    stack = [(start, [])]
    visited = set()
    while stack:
        state, path = stack.pop()
        state_tuple = tuple(tuple(row) for row in state)
        if state_tuple in visited:
            continue
        visited.add(state_tuple)

        if is_goal(state):
            return path + [state]

        if len(path) < depth_limit:  # depth-limited brute force
            for neighbor in get_neighbors(state):
                stack.append((neighbor, path + [state]))
    return None

# Example
start = [[1,2,3],
         [4,0,6],
         [7,5,8]]

solution = dfs(start)
print("DFS Solution length:", len(solution) if solution else "Not found")


2.static g 

import heapq

goal = [[1,2,3],
        [4,5,6],
        [7,8,0]]

moves = [(1,0), (-1,0), (0,1), (0,-1)]  # Down, Up, Right, Left

def find_blank(state):
    for i in range(3):
        for j in range(3):
            if state[i][j] == 0:
                return i, j

def is_goal(state):
    return state == goal

def get_neighbors(state):
    x, y = find_blank(state)
    neighbors = []
    for dx, dy in moves:
        nx, ny = x + dx, y + dy
        if 0 <= nx < 3 and 0 <= ny < 3:
            new_state = [row[:] for row in state]
            new_state[x][y], new_state[nx][ny] = new_state[nx][ny], new_state[x][y]
            neighbors.append(new_state)
    return neighbors

def manhattan(state):
    """Heuristic: Manhattan distance"""
    dist = 0
    for i in range(3):
        for j in range(3):
            val = state[i][j]
            if val != 0:
                target_x = (val-1) // 3
                target_y = (val-1) % 3
                dist += abs(i - target_x) + abs(j - target_y)
    return dist

def astar(start):
    pq = []
    heapq.heappush(pq, (0, start, [], 0))  # (f, state, path, g)
    visited = set()

    while pq:
        f, state, path, g = heapq.heappop(pq)
        state_tuple = tuple(tuple(row) for row in state)
        if state_tuple in visited:
            continue
        visited.add(state_tuple)

        if is_goal(state):
            return path + [state]

        for neighbor in get_neighbors(state):
            new_g = g + 1  # static g = +1 per step
            h = manhattan(neighbor)
            new_f = new_g + h
            heapq.heappush(pq, (new_f, neighbor, path + [state], new_g))
    return None

# Example
start = [[1,2,3],
         [4,0,6],
         [7,5,8]]

solution = astar(start)
print("A* Solution length:", len(solution) if solution else "Not found")

3.IDDFS without manhattan
goal = [[1,2,3],
        [4,5,6],
        [7,8,0]]

moves = [(1,0), (-1,0), (0,1), (0,-1)]  # Down, Up, Right, Left

def find_blank(state):
    for i in range(3):
        for j in range(3):
            if state[i][j] == 0:
                return i, j

def is_goal(state):
    return state == goal

def get_neighbors(state):
    x, y = find_blank(state)
    neighbors = []
    for dx, dy in moves:
        nx, ny = x + dx, y + dy
        if 0 <= nx < 3 and 0 <= ny < 3:
            new_state = [row[:] for row in state]
            new_state[x][y], new_state[nx][ny] = new_state[nx][ny], new_state[x][y]
            neighbors.append(new_state)
    return neighbors

def dls(state, depth, path, visited):
    if is_goal(state):
        return path + [state]
    if depth == 0:
        return None
    visited.add(tuple(tuple(row) for row in state))
    for neighbor in get_neighbors(state):
        state_tuple = tuple(tuple(row) for row in neighbor)
        if state_tuple not in visited:
            result = dls(neighbor, depth-1, path+[state], visited)
            if result:
                return result
    return None

def iddfs(start, max_depth=30):
    for depth in range(max_depth):
        visited = set()
        result = dls(start, depth, [], visited)
        if result:
            return result
    return None



4.IDDFS with manhattan
def manhattan(state):
    dist = 0
    for i in range(3):
        for j in range(3):
            val = state[i][j]
            if val != 0:
                target_x = (val-1) // 3
                target_y = (val-1) % 3
                dist += abs(i - target_x) + abs(j - target_y)
    return dist

def ida_star(start):
    def search(path, g, bound):
        state = path[-1]
        f = g + manhattan(state)
        if f > bound:
            return f
        if is_goal(state):
            return "FOUND"
        min_threshold = float("inf")
        for neighbor in get_neighbors(state):
            if neighbor not in path:
                path.append(neighbor)
                result = search(path, g+1, bound)
                if result == "FOUND":
                    return "FOUND"
                if result < min_threshold:
                    min_threshold = result
                path.pop()
        return min_threshold

    bound = manhattan(start)
    path = [start]
    while True:
        result = search(path, 0, bound)
        if result == "FOUND":
            return path
        if result == float("inf"):
            return None
        bound = result




